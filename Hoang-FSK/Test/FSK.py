import numpy as np
import matplotlib.pyplot as plt

# Generate the binary data sequence
# binary_data: The binary data sequence that will be modulated.
binary_data = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0] 

# Constants
N = 1000 # The number of samples in the time domain.
f1 = 100 # The frequency of the first carrier signal. 
f2 = 50 # The frequency of the second carrier signal
t = np.linspace(0, 1, N) # The time vector, generated using the numpy function "linspace" from 0 to 1 with N samples.
N0 = 2 # The power spectral density of the Gaussian noise.

# Generate the carrier signals
# carrier1: The first carrier signal, generated using the numpy cosine function with 2pif1*t as the argument.
carrier1 = np.cos(2*np.pi*f1*t) 
# carrier2: The second carrier signal, generated using the numpy cosine function with 2pif2*t as the argument.
carrier2 = np.cos(2*np.pi*f2*t) 


# Perform FSK modulation
# fsk_modulated_signal: The FSK modulated signal, generated by replacing each symbol of the binary data with the corresponding carrier signal.
fsk_modulated_signal = np.zeros(N) 
for i in range(len(binary_data)):
    if binary_data[i] == 1:
        fsk_modulated_signal[i*N//len(binary_data):(i+1)*N//len(binary_data)] = carrier1[i*N//len(binary_data):(i+1)*N//len(binary_data)]
    else:
        fsk_modulated_signal[i*N//len(binary_data):(i+1)*N//len(binary_data)] = carrier2[i*N//len(binary_data):(i+1)*N//len(binary_data)]

# Add Gaussian noise
# mul: The multiplier of the Gaussian noise
mul = 10;  
# noise: The Gaussian noise, generated using the numpy random function with the mean and standard deviation set to 0 and sqrt(N0/2), respectively.
noise = mul * np.sqrt(N0/2) * np.random.randn(N) 
# r: The noisy FSK modulated signal, obtained by adding the noise to the fsk_modulated_signal.
r = fsk_modulated_signal + noise


# Set threshold for decision
# threshold: The decision threshold for FSK demodulation.
threshold = 0 

# Perform FSK demodulation
# demodulated_binary_data: The demodulated binary data, obtained by deciding the symbol based on the decision variable calculated from the correlation between the noisy signal and each carrier signal.
demodulated_binary_data = np.zeros(len(binary_data)) 
for i in range(len(binary_data)):
    data_segment = r[i*(N//len(binary_data)):(i+1)*(N//len(binary_data))]
    carrier1_segment = carrier1[i*(N//len(binary_data)):(i+1)*(N//len(binary_data))]
    carrier2_segment = carrier2[i*(N//len(binary_data)):(i+1)*(N//len(binary_data))]
    decision_variable1 = np.sum(data_segment * carrier1_segment)
    decision_variable0 = np.sum(data_segment * carrier2_segment)
    if decision_variable1 - decision_variable0 > threshold:
        demodulated_binary_data[i] = 1
    else:
        demodulated_binary_data[i] = 0

# Compute the error probability
# error_probability: The error probability, calculated as the ratio of the number of incorrect symbols to the total number of symbols.
error_probability = np.sum(np.abs(binary_data - demodulated_binary_data)) / len(binary_data) 

# plt: The matplotlib library for plotting the results.
plt.figure()
plt.subplot(511)
plt.title("Binary Data", fontsize='8')
plt.plot(binary_data, 'o-', markersize=8, color='red')

plt.subplot(512)
plt.title("Carrier Signal 1", fontsize='8')
plt.plot(carrier1)

plt.subplot(513)
plt.title("Carrier Signal 2", fontsize='8')
plt.plot(carrier2)

plt.subplot(514)
plt.title("FSK Modulated Signal", fontsize='8')
plt.plot(r)

plt.subplot(515)
plt.title("Demodulated Binary Data", fontsize='8')
plt.plot(demodulated_binary_data, 'o-', markersize=8, color='red')

plt.tight_layout()
plt.show()

print("Error Probability:", error_probability)